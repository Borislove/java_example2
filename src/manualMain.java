//import javafx.embed.swt.FXCanvas$7;

public class manualMain {

    // объявляется класс Main
    // void означает простая обработка без возврата как обычная процедура

    /*
    public
    Разбивая эту строку на отдельные лексемы, мы сразу сталкиваемся с ключевым словом public.
    Это - модификатор доступа, который позволяет программисту управлять видимостью любого метода
    и любой переменной. В данном случае модификатор доступа public означает, что метод main виден
    и доступен любому классу. Существуют еще 2 указателя уровня доступа - private и protected


    static
    Следующее ключевое слово - static. С помощью этого слова объявляются методы(процедуры или функции)
    и переменные класса, используемые для работы с классом в целом. Методы, в объявлении которых
    использовано ключевое слово static,
    могут непосредственно работать только с локальными и статическими переменными.



    void
    У вас нередко будет возникать потребность в методах, которые возвращают значение того или иного типа:
    например, int для целых значений, float - для вещественных или имя класса для типов данных, определенных
    программистом. В нашем случае нужно просто вывести на экран строку, а возвращать значение из метода main
    не требуется. Именно поэтому и был использован модификатор void.

    main
    Наконец, мы добрались до имени метода main. Здесь нет ничего необычного, просто все существующие реализации
    Java-интерпретаторов, получив команду интерпретировать класс, начинают свою работу с вызова метода main.
    Java-транслятор может оттранслировать класс, в котором нет метода main. А вот Java-интерпретатор запускать
    классы без метода main не умеет. Все параметры, которые нужно передать методу, указываются внутри пары круглых
    скобок в виде списка элементов, разделенных символами ";" (точка с запятой). Каждый элемент списка параметров
    состоит из разделенных пробелом типа и идентификатора. Даже если у метода нет параметров, после его имени все
    равно нужно поставить пару круглых скобок. В примере, который мы сейчас обсуждаем, у метода main только один
    параметр, правда довольно сложного типа. Элемент String args[] объявляет параметр с именем args, который является
    массивом объектов - представителей класса String. Обратите внимание на квадратные скобки, стоящие после
    идентификатора args. Они говорят о том, что мы имеем дело с массивом, а не с одиночным элементом указанного типа.
    Мы вернемся к обсуждению массивов в следующей главе, а пока отметим, что тип String - это класс.
    */


/*
        Алгори́тм (лат. al­go­rithmi — от арабского имени математика Аль-Хорезми[1]) — конечная совокупность
        точно заданных правил решения произвольного класса задач или набор инструкций, описывающих порядок
      действий исполнителя для решения некоторой задачи. В старой трактовке вместо слова «порядок»
      использовалось слово «последовательность», но по мере развития параллельности в работе компьютеров
      слово «последовательность» стали заменять более общим словом «порядок». Независимые инструкции
      могут выполняться в произвольном порядке, параллельно, если это позволяют используемые исполнители.
      Ранее в русском языке писали «алгорифм», сейчас такое написание используется редко, но, тем не менее,
      имеет место исключение (нормальный алгорифм Маркова).

      Часто в качестве исполнителя выступает компьютер, но понятие алгоритма необязательно относится к
     компьютерным программам, так, например, чётко описанный рецепт приготовления блюда также является
      алгоритмом, в таком случае исполнителем является человек (а может быть и некоторый механизм,
       ткацкий станок, и пр.).

    Можно выделить алгоритмы вычислительные (о них в основном идет далее речь), и управляющие. Вычислительные
     по сути преобразуют некоторые начальные данные в выходные, реализуя вычисление некоторой функции.
      Семантика управляющих алгоритмов существенным образом может отличаться и сводиться к выдаче необходимых
       управляющих воздействий либо в заданные моменты времени, либо в качестве реакции на внешние события
        (в этом случае, в отличие от вычислительного алгоритма, управляющий может оставаться корректным при
         бесконечном выполнении).

    Понятие алгоритма относится к первоначальным, основным, базисным понятиям математики. Вычислительные
     процессы алгоритмического характера (арифметические действия над целыми числами, нахождение наибольшего
      общего делителя двух чисел и т. д.) известны человечеству с глубокой древности. Однако в явном виде
       понятие алгоритма сформировалось лишь в начале XX века.

    Частичная формализация понятия алгоритма началась с попыток решения проблемы разрешения (нем. Entscheidungsproblem),
     которую сформулировал Давид Гильберт в 1928 году. Следующие этапы формализации были необходимы для определения
      эффективных вычислений[2] или «эффективного метода»[3]; среди таких формализаций — рекурсивные
       функции Геделя — Эрбрана — Клини 1930, 1934 и 1935 гг., λ-исчисление Алонзо Чёрча 1936 г.,
        «Формулировка 1» Эмиля Поста 1936 года и машина Тьюринга.
*/

/*
    Схема предиктор-корректор (метод прогноза и коррекции,
     предсказывающе-исправляющий метод[1]) — в вычислительной математике
      — семейство алгоритмов численного решения различных задач,
       которые состоят из двух шагов. На первом шаге (предиктор)
        вычисляется грубое приближение требуемой величины.
         На втором шаге при помощи иного метода приближение
          уточняется (корректируется).

    Являются одними из наиболее популярных многошаговых методов.[2]
*/

/*
    Предиктор
    Материал из Википедии — свободной энциклопедии
    Перейти к навигацииПерейти к поиску
    Предиктор (от англ. predictor «предсказатель») — прогностический параметр; средство прогнозирования. Термин употребляется в различных областях:

    экстраполяционная функция (матем.);
    Конечно-разностная схема предиктор-корректор для решения дифференциальных уравнений.
            показатель, прогностический фактор (мед.);
    независимая переменная; прогнозирующее устройство; экстраполятор; прогнозирующий параметр (техн.);
    структурно организованная система, функцией которой является прогнозирование, т. е. независимая переменная (экон.).
    */

/*
    Slope One — семейство алгоритмов для коллаборативной фильтрации (используемой в рекомендательных системах) для анализа различных мнений и пожеланий пользователей и выработки персональных рекомендаций.

    Существует как минимум 2 класса коллаборативной фильтрации:

    фильтрация по схожести пользователей (англ. user-based filtration), базирующаяся на измерении подобия пользователей;
    фильтрация по схожести предметов (англ. item-based filtration), сравнивающая оценки, данные различными пользователями.
    Slope One был представлен в статье Slope One Predictors for Online Rating-Based Collaborative Filtering Даниелем Лемайром (англ. Daniel Lemire) и Анной Маклахлан (англ. Anna Maclachlan). Утверждается, что это один из самых простых способов коллаборативной фильтрации по схожести предметов на основании оценок пользователей. Эта простота значительно облегчает внедрение данных алгоритмов, а их точность сравнима с точностью более сложных и ресурсоёмких алгоритмов[1]. Slope One также часто дополняет другие алгоритмы.[2][3].

    */

    public static void main(String[] args) // так включаются программы,

    {
        System.out.println();
// объявление переменных
        int intt = 10; // целое число
        boolean vb = true;   // тип булево истина или ложь
        byte fv = 124; // целое маленькое число от -128 до 127
        //char ; //
        //double ; //
        float ала = 9; //.0f //54.545f; // число с плавующей точкой
        //long  ; //
        //short ; //

// вывод на экран
        // переменная "сторка" "String" как строка
        String строка = " Строка длииииная ";
        System.out.println("Отображние данных: " + ала + " " + " Строковое значание:  " + строка);

        System.out.println();
//условный операторы
        if (ала >= 10) {
            System.out.println("Условный оператор проверка \"ала\" >= 10 ");
        } else {
            System.out.println("Условный оператор переменная \"ала\" < 10");
        }

        System.out.println();
// циклы
        // цикл  for ([инициализация счетчика]; [условие]; [изменение счетчика])
        //        {
        //            // действия
        //        }
        for (int nm = 1; nm <= 10; nm++) {
            System.out.println("Результат: " + nm);
        }

        System.out.println();
        //        Цикл do сначала выполняет код цикла, а потом проверяет условие в инструкции while.
        //        и пока это условие истинно, цикл повторяется.
        int jj = 7;
        do {
            System.out.println("Цикл \"do\" по убыванию: " + jj);
            jj--;
        }
        while (jj > 0);

        System.out.println();
        //        Цикл while сразу проверяет истинность некоторого условия, и если условие истинно,
        //        то код цикла выполняется:
        int j = 6;
        while (j > 0) {
            System.out.println("Цикл \"while\": " + j);
            j--;
        }

        System.out.println();
        //        Операторы continue и break
        //        Оператор break позволяет выйти из цикла в любой его момент,
        //        даже если цикл не закончил свою работу
        //        Когда счетчик станет равным 5, сработает оператор break, и цикл завершится
        for (int i = 0; i < 10; i++) {
            if (i == 5)
                break;
            System.out.println("Тут должен сработать цикл, но не сработает если \"i\" будет \n" +
                    "равен 5 сработает оператор \"break\": " + "\n"
                    + i);
        }

        System.out.println();
        //        оператор continue
        //        Теперь сделаем так, чтобы если число равно 5, цикл не завершался,
        //        а просто переходил к следующей итерации т.е. вернется сразу
        //        к началу циклва не дойдя до конца тела цикла
        for (int i = 0; i < 10; i++) {
            if (i == 5)
                continue;
            System.out.println("Оператор \"continue\" проверка на число 5: " + i);
        }

        System.out.println();
// массивы
        //  Массив представляет набор однотипных значений. Объявление массива похоже на объявление обычной переменной,
        //  которая хранит одиночное значение, причем есть два способа объявления массива:
        //        тип_данных название_массива[];
        //  либо
        //        тип_данных[] название_массива;
        //
        //        int nums[];
        //        int[] nums2;
        //
        //        После объявления массива мы можем инициализовать его:
        //        int nums[];
        //        nums = new int[4];  // массив из 4 чисел
        //
        //        Создание массива производится с помощью следующей конструкции:
        //        new тип_данных[количество_элементов], где new - ключевое слово, выделяющее память
        //        для указанного в скобках количества элементов. Например, nums = new int[4];
        //        - в этом выражении создается массив из четырех элементов int, и каждый элемент будет
        //        иметь значение по умолчанию - число 0.
        //
        //        int nums[] = new int[4];    // массив из 4 чисел
        //        int[] nums2 = new int[5];   // массив из 5 чисел
        //
        //        При подобной инициализации все элементы массива имеют значение по умолчанию.
        //        Для числовых типов (в том числе для типа char) это число 0,
        //        для типа boolean это значение false,
        //        а для остальных объектов это значение null.
        //        Например, для типа int значением по умолчанию является число 0,
        //        поэтому выше определенный массив nums будет состоять из четырех нулей.
        //
        //        Также можно задать конкретные значения для элементов массива при его создании
        //
        //          эти два способа равноценны
        //        int[] nums = new int[] { 1, 2, 3, 5 };
        //
        //        int[] nums2 = { 1, 2, 3, 5 };
        //
        //        Стоит отметить, что в этом случае в квадратных скобках не указывается размер массива,
        //        так как он вычисляется по количеству элементов в фигурных скобках.

        int[] nums = new int[4];
        // устанавливаем значения элементов массива
        nums[0] = 1;
        nums[1] = 2;
        nums[2] = 4;
        nums[3] = 100;
        // получаем значение третьего элемента массива
        System.out.println("Получаем значение массива: " + nums[2]);    // 4 (3 по порядку начиная с 1)

        // Индексация элементов массива начинается с 0, поэтому в данном случае, чтобы обратиться
        // к четвертому элементу в массиве, нам надо использовать выражение nums[3]

        System.out.println();
        // Важнейшее свойство, которым обладают массивы, является свойство length,
        // возвращающее длину массива, то есть количество его элементов
        int[] numss = {1, 2, 3, 4, 5};
        int length = numss.length;   // 5
        System.out.println("Получаем количество элементов в массиве: " + numss.length);

        System.out.println();
        //        Нередко бывает неизвестным последний индекс,
        //        и чтобы получить последний элемент массива, мы можем использовать это свойство
        int last = numss[numss.length - 1];
        System.out.println("Получаем значение последнего элемента массива: " + numss[numss.length - 1]);

        System.out.println();
        //многомерный массив
        //        int[][] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
        //        или
        //        int[][] nums2 = new int[2][3];
        //        Количество квадратных скобок указывает на размерность массива.
        //        А числа в скобках - на количество строк и столбцов.

        // установим элемент первого столбца второй строки
        int[][] nums2 = new int[2][3]; // 2 строки 3 столбца
        nums2[1][0] = 44;
        System.out.println(nums2[1][0]);

        //Объявление трехмерного массива могло бы выглядеть так:
        int[][][] nums3 = new int[2][3][4];

        // Так же мы можем каждому элементу в двухмерном массиве присвоить отдельный массив
        // с различным количеством элементов
        int[][] numsZ = new int[3][];
        numsZ[0] = new int[2];
        numsZ[1] = new int[3];
        numsZ[2] = new int[5];

        System.out.println();
        //        for each
        //        цикл for предназначен для перебора элементов в наборах элементов,
        //        в массивах и коллекциях.
        //     for (тип_данных название_переменной : контейнер){ // смотрим на двоеточие
        //           какие то действия
        //      }
        //        В качестве контейнера в данном случае выступает массив данных типа int.
        int[] array = new int[]{1, 2, 3, 4, 5};
        for (int i : array) {
            System.out.println(i);
        }
        //        То же самое можно было бы сделать и с помощью обычной версии for:
        //        int[] array = new int[] { 1, 2, 3, 4, 5 };
        //        for (int i = 0; i < array.length; i++){
        //            System.out.println(array[i]);
        //        }

        System.out.println();
        // Перебор многомерных массивов в цикле
        // Сначала создается цикл для перебора по строкам,
        // а затем внутри первого цикла создается внутренний цикл для перебора
        // по столбцам конкретной строки.
        int[][] numsPr = new int[][]
                {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                };
        for (int i = 0; i < numsPr.length; i++) {       // строки
            for (int jjj = 0; jjj < numsPr[i].length; jjj++)    // столбцы
            {
                System.out.printf("%d ", numsPr[i][jjj]);
            }
            System.out.println(); // отображение индекса строки
        }

        System.out.println();
// Методы
        //-------------------------------------------------------------------------------------
        //  Общее определение методов выглядит следующим образом:
        //
        //        [модификаторы] тип_возвращаемого_значения название_метода ([параметры])
        //        {
        //          тело метода
        //         }
        //   Модификаторы и параметры необязательны.
        // По умолчанию главный класс любой программы на Java содержит метод main,
        // который служит точкой входа в программу
        //
        //    public static void main(String[] args) {
        //        System.out.println("привет мир!");
        //    }
        //
        //        Ключевые слова public и static являются модификаторами.
        //        Далее идет тип возвращаемого значения.
        //        Ключевое слово void указывает на то, что метод ничего не возвращает.
        //
        //        Затем идут название метода - main
        //        и в скобках параметры метода - String[] args.
        //        И в фигурные скобки заключено тело метода
        //        - все действия, которые он выполняет.
        //
        //        public class Program{ // название класса "Program"
        //            public static void main (String args[])  // т.е. String args[] это параметры
        //            {
        //            }
        //            void hello(){
        //                System.out.println("Hello");
        //            }
        //            void welcome()
        //            {
        //                System.out.println("Welcome to Java 10");
        //            }
        //            }
        //        Здесь определены два дополнительных метода:
        //        hello и welcome, каждый из которых выводит некоторую строку на консоль.
        //        Методы определяются внутри класса Program, в котором определен метод main.
        //
        //        имя_метода(аргументы);
        //        После имени метода указываются скобки,
        //        в которых перечисляются аргументы (параметры) или значения параметров
        //
        //                    public class Program{
        //                        public static void main (String args[]){
        //                            hello();
        //                            welcome();
        //                            welcome();
        //                        }
        //                        static void hello(){
        //                            System.out.println("Hello");
        //                        }
        //                        static void welcome(){
        //                            System.out.println("Welcome to Java");
        //                        }
        //                    }
        //        В примере мы вынесли некоторые общие действия в отдельный метод
        //        и затем вызываем  многократно их в различных местах программы.
        //        Поскольку оба метода не имеют никаких параметров, то после их
        //        названия при вызове ставятся пустые скобки.
        //
        //        Также следует отметить, то что бы вызвать в методе main другие методы,
        //        которые определены в одном классе с методом main,
        //        они должны иметь модификатор static.
        //--------------------------------------------------------------------------------------


// Параметры методов
        //        С помощью параметров мы можем передать в методы различные данные,
        //        которые будут использоваться для вычислений. Например:
        //
        //        static void sum(int x, int y){
        //
        //        int z = x + y;
        //        System.out.println(z);
        //    }
        //        Данная функция принимает два параметра - два числа,
        //        складывает их и выводит их сумму на консоль.
        //
        //            А при вызове этого метода в программе нам необходимо передать
        //            на место параметров значения, которые соответствуют типу параметра:
        //
        //        public class Program{
        //            public static void main (String args[]){
        //                int a = 6;
        //                int b = 8;
        //                sum(a, b);  // 14
        //                sum(3, a);  // 9
        //                sum(5, 23); // 28
        //            }
        //            static void sum(int x, int y){
        //
        //                int z = x + y;
        //                System.out.println(z);
        //            }
        //        }
        //        Поскольку метод sum принимает два значения типа int, то на место параметров
        //        надо передать два значения типа int. Это могут быть и числовые литералы, и переменные
        //        типов данных, которые представляют тип int или могут быть автоматически преобразованы
        //        в тип int. Значения, которые передаются на место параметров, еще называются аргументами.
        //        Значения передаются параметрам по позиции, то есть первый аргумент первому параметру,
        //        второй аргумент - второму параметру и так далее.
        //
        //        другой пример:
        //        public class Program{
        //            public static void main (String args[]){
        //                display("Tom", 34);
        //                display("Bob", 28);
        //                display("Sam", 23);
        //            }
        //            static void display(String name, int age){
        //                System.out.println(name);
        //                System.out.println(age);
        //            }
        //        }
        //        Метод display принимает два параметра. Первый параметр представляет тип String,
        //        а второй - тип int. Поэтому при вызове метода вначале в него надо передать строку,
        //        а затем число.
        //
        //        Параметры переменной длины
        //        Метод может принимать параметры переменной длины одного типа. Например, нам надо
        //        передать в метод набор числел и ычислить их сумму, но мы точно не знаем,
        //        сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной
        //        длины позволяют решить эту задачу:
        //
        //        public class Program{
        //            public static void main (String args[]){
        //                sum(1, 2, 3);           // 6
        //                sum(1, 2, 3, 4, 5);     // 15
        //                sum();                  // 0
        //            }
        //            static void sum(int ...nums){
        //                int result =0;
        //                for(int n: nums)
        //                    result += n;
        //                System.out.println(result);
        //            }
        //        }
        //
        //        Троеточие перед названием параметра int ...nums указывает на то, что он будет
        //        необязательным и будет представлять массив. Мы можем передать в метод sum одно число,
        //        несколько чисел, а можем вообще не передавать никаких параметров. Причем, если мы
        //        хотим передать несколько параметров, то необязательный параметр должен указываться в конце:
        //
        //        public static void main(String[] args) {
        //        sum("Welcome!", 20,10);
        //        sum("Hello World!");
        //    }
        //        static void sum(String message, int ...nums){
        //
        //        System.out.println(message);
        //        int result =0;
        //        for(int x:nums)
        //            result+=x;
        //        System.out.println(result);
        //    }
        //
        //--------------------------------------------------------------------------------------

//оператор return.
        //
        //        return возвращаемое_значение;
        //
        //        После оператора return указывается возвращаемое значение, которое является результатом
        //        метода. Это может быть литеральное значение, значение переменной или какого-то сложного выражения.
        //
        //        public class Program{
        //            public static void main (String args[]){
        //                int x = sum(1, 2, 3);
        //                int y = sum(1, 4, 9);
        //                System.out.println(x);  // 6
        //                System.out.println(y);  // 14
        //            }
        //            static int sum(int a, int b, int c){
        //                return a + b + c;
        //            }
        //        }
        //
        //        В методе в качестве типа возвращаемого значения вместо void используется любой другой тип.
        //        В данном случае метод sum возвращает значение типа int, поэтому этот тип указывается перед
        //        названием метода. Причем если в качестве возвращаемого типа для метода определен любой другой,
        //        отличный от void, то метод обязательно должен использовать оператор return для возвращения значения.
        //
        //        При этом возвращаемое значение всегда должно иметь тот же тип, что значится в определении функции.
        //        И если функция возвращает значение типа int, то после оператора return стоит целочисленное значение,
        //        которое является объектом типа int. Как в данном случае это сумма значений параметров метода.
        //
        //        Метод может использовать несколько вызовов оператора return для возваращения разных значений в зависимости
        //        от некоторых условий:
        //
        //        public class Program{
        //            public static void main (String args[]){
        //                System.out.println(daytime(7));     // Good morning
        //                System.out.println(daytime(13));    // Good after noon
        //                System.out.println(daytime(18));    // Good evening
        //                System.out.println(daytime(2));     // Good night
        //            }
        //            static String daytime(int hour){
        //
        //                if (hour >24 || hour < 0)
        //                    return "Invalid data";
        //                else if(hour > 21 || hour < 6)
        //                    return "Good night";
        //                else if(hour >= 15)
        //                    return "Good evening";
        //                else if(hour >= 11)
        //                    return "Good after noon";
        //                else
        //                    return "Good morning";
        //            }
        //        }
        //
        //        Здесь метод daytime возвращает значение типа String, то есть строку, и в зависимости от
        //        значения параметра hour возвращаемая строка будет различаться.
        //        Выход из метода
        //        Оператор return применяется для возвращаения значения из метода, но и для выхода из метода.
        //        В подобном качестве оператор return применяется в методах, которые ничего не возвращают,
        //        то есть имеют тип void:
        //
        //        public class Program{
        //            public static void main (String args[]){
        //                daytime(7);     // Good morning
        //                daytime(13);    // Good after noon
        //                daytime(32);    //
        //                daytime(56);    //
        //                daytime(2);     // Good night
        //            }
        //            static void daytime(int hour){
        //
        //                if (hour >24 || hour < 0)
        //                    return;
        //                if(hour > 21 || hour < 6)
        //                    System.out.println("Good night");
        //                else if(hour >= 15)
        //                    System.out.println("Good evening");
        //                else if(hour >= 11)
        //                    System.out.println("Good after noon");
        //                else
        //                    System.out.println("Good morning");
        //            }
        //        }
        //
        //        Если переданное в метод datetime значение больше 24 или меньше 0, то просто выходим из метода.
        //        Возвращаемое значение после return указывать в этом случае не нужно.
        //
        //--------------------------------------------------------------------------------------

//перегрузкой методов
        //        В программе мы можем использовать методы с одним и тем же именем,
        //        но с разными типами и/или количеством параметров.
        //        Такой механизм называется перегрузкой методов (method overloading).
        //
        //        public class Program{
        //            public static void main(String[] args) {
        //                System.out.println(sum(2, 3));          // 5
        //                System.out.println(sum(4.5, 3.2));      // 7.7
        //                System.out.println(sum(4, 3, 7));       // 14
        //            }
        //            static int sum(int x, int y){
        //                return x + y;
        //            }
        //            static double sum(double x, double y){
        //                return x + y;
        //            }
        //            static int sum(int x, int y, int z){
        //                return x + y + z;
        //            }
        //        }
        //
        //        Здесь определено три варианта или три перегрузки метода sum(),
        //        но при его вызове в зависимости от типа и количества передаваемых параметров
        //        система выберет именно ту версию, которая наиболее подходит.
        //
        //        Стоит отметить, что на перегрузку методов влияют количество и типы параметров.
        //        Однако различие в типе возвращаемого значения для перегрузки не имеют никакого
        //        значения.
        //        public class Program{
        //            public static void main(String[] args) {
        //                System.out.println(sum(2, 3));
        //                System.out.println(sum(4, 3));
        //            }
        //            static int sum(int x, int y){
        //                return x + y;
        //            }
        //            static double sum(int x, int y){
        //                return x + y;
        //            }
        //        }
        //
        //        Однако перегрузкой это не будет считаться.
        //        Более того такая программа некорректна и попросту не скомилируется,
        //        так как метод с одним и тем же количеством и типом параметров определен несколько раз.
        //
        //        Следует при перегрузке прописывать ключевое слово @Overload,
        //        так компилятор Java (javac) сразу определит что данный метод является перегруженным.
        //
        //        static int test (int x) {}
        //        @Overload
        //        static int test (int x, int y) {}
        //--------------------------------------------------------------------------------------


//Рекурсия
        //        Рекурсивные функции
        //        Главное отличие рекурсивных функций от обычных методов состоит в том,
        //          что рекурсивная функция вызывает саму себя
        //        static int factorial(int x){
        //        if (x == 1){
        //            return 1;
        //        }
        //        return x * factorial(x - 1);
        //    }
        //        Вначале проверяется условие: если вводимое число не равно 1,
        //        то мы умножаем данное число на результат этой же функции,
        //        в которую в качестве параметра передается число x-1.
        //        То есть происходит рекурсивный спуск.
        //        И так дальше, пока не дойдем того момента,
        //        когда значение параметра не будет равно единице.
        //
        //        Рекурсивная функция обязательно должна иметь некоторый базовый вариант,
        //        который использует оператор return и который помещается в начале функции.
        //        В случае с факториалом это if (x == 0) return 1;.
        //        И все рекурсивные вызовы должны обращаться к подфункциям,
        //        которые в конечном счете сходятся к базовому варианту.
        //
        //        Так, при передаче в функцию положительного числа при
        //        дальнейших рекурсивных вызовах
        //        подфункций в них будет передаваться каждый раз число,
        //        меньшее на единицу. И в конце концов мы дойдем до ситуации,
        //        когда число будет равно 0, и будет использован базовый вариант.
        //
        //        Еще одним распространенным примером рекурсивной функции служит функция,
        //        вычисляющая числа Фибоначчи.
        //        В теории n-й член последовательности Фибоначчи определяется по формуле:
        //        f(n)=f(n-1) + f(n-2), причем f(0)=0, а f(1)=1.
        //
        //        static int fibonachi(int n){
        //        if (n == 0){
        //            return 0;
        //        }
        //        if (n == 1){
        //            return 1;
        //        }
        //        else{
        //            return fibonachi(n - 1) + fibonachi(n - 2);
        //        }}
        //
        //        Комменты metanit.com/java/tutorial/2.8.php
        //
        //        Для фибоначчи лучше рекурсию все же не применять.
        //        Тут следует понимать что при рекурсии образуется т.н.
        //        стек вызовов функций.
        //        А при двойной рекурсии стек так же будет двойным,
        //        что конечно же еще как скажется на память.
        //
        //        По отношению к ресурсивным действиям обычно применяют два понятия:
        //        рекурсивные методы и рекурсивные функции, причем последнее используется гораздо чаще.
        //        Если речь идет просто о нерекурсивных действиях классах, то их обычно называют методами.
        //
        //        Не раскрыта важная тема хвостовой рекурсии.
        //        Хвостовая рекурсия - частный случай рекурсии,
        //        при котором любой рекурсивный вызов является
        //        последней операцией перед возвратом из функции.
        //        Рекомендуется применять в коде именно хвостовую рекурсию,
        //        в этом случае компилятор может превратить медленные рекурсивные
        //        вызовы в быстрый цикл и, самое главное, не использовать стек.
        //        Например, для факториала это возможно, а для чисел Фибоначчи (в данном примере) - нет.
        //        К сожалению, компилятор Java оптимизировать хвостовую рекурсию не умеет (Scala и C# умеют).
        //
        //        А почему вычисления на основе цикла является более оптимальным решением, нежели рекурсия ?
        //        Рекурсия занимает больше памяти так как стек методов будет разворачиваться
        //        пока не достигнет условия выхода. в цикле такого происходить не будет.
        //--------------------------------------------------------------------------------------

//Обработка исключений
        //
        //        Нередко в процессе выполнения программы могут возникать ошибки,
        //        при том необязательно по вине разработчика. Некоторые из них трудно
        //        предусмотреть или предвидеть, а иногда и вовсе невозможно. Так, например,
        //        может неожиданно оборваться сетевое подключение при передаче файла.
        //        Подобные ситуации называются исключениями.
        //
        //        В языке Java предусмотрены специальные средства для обработки
        //        подобных ситуаций. Одним из таких средств является конструкция
        //        try...catch...finally.
        //
        //        При возникновении исключения в блоке try
        //        управление переходит в блок catch, который может обработать данное исключение.
        //        Если такого блока не найдено, то пользователю отображается сообщение
        //        о необработанном исключении, а дальнейшее выполнение программы останавливается.
        //        И чтобы подобной остановки не произошло, и надо использовать
        //        блок try..catch.
        //
        //        int[] numbers = new int[3];
        //        numbers[4]=45;
        //        System.out.println(numbers[4]);
        //
        //           Так как у нас массив numbers может содержать только 3 элемента,
        //        то при выполнении инструкции numbers[4]=45 консоль отобразит исключение,
        //        и выполнение программы будет завершено.
        //        Теперь попробуем обработать это исключение:
        try {
            int[] numbers = new int[3];
            numbers[4] = 45;
            System.out.println(numbers[4]);
        } catch (Exception ex) {

            ex.printStackTrace();
        }
        System.out.println("Программа завершена");
        //
        //        При использовании блока
        //        try...catch
        //        вначале выполняются все инструкции между операторами
        //        try и catch.
        //        Если в блоке try вдруг возникает исключение,
        //        то обычный порядок выполнения останавливается
        //        и переходит к инструкции сatch.
        //        Поэтому когда выполнение программы дойдет до строки
        //        numbers[4]=45;, программа остановится и перейдет к блоку catch
        //
        //        Выражение catch имеет следующий синтаксис:
        //        catch (тип_исключения имя_переменной).
        //
        //        В данном случае объявляется переменная ex,
        //        которая имеет тип Exception.
        //        Но если возникшее исключение не является исключением типа,
        //        указанного в инструкции сatch,
        //        то оно не обрабатывается, а программа просто зависает или выбрасывает сообщение об ошибке.
        //
        //        Но так как тип Exception является базовым классом для всех исключений,
        //        то выражение catch (Exception ex) будет обрабатывать практически все исключения.
        //        Обработка же исключения в данном случае сводится к выводу на консоль стека
        //        трассировки ошибки с помощью метода printStackTrace(), определенного в классе Exception.
        //
        //            После завершения выполнения блока catch программа продолжает свою работу,
        //            выполняя все остальные инструкции после блока catch.
        //
        //        Конструкция try..catch также может иметь блок finally.
        //        Однако этот блок необязательный, и его можно при обработке исключений
        //        опускать.
        //        Блок finally выполняется в любом случае, возникло ли исключение в блоке try или нет:
        try {
            int[] numbers = new int[3];
            numbers[4] = 45;
            System.out.println(numbers[4]);
        } catch (Exception ex) {

            ex.printStackTrace();
        } finally {
            System.out.println("Блок finally");
        }
        System.out.println("Программа завершена");

        //        Обработка нескольких исключений
        //        В Java имеется множество различных типов исключений,
        //        и мы можем разграничить их обработку,
        //        включив дополнительные блоки catch:
        int[] numbers = new int[3];
        try {
            numbers[6] = 45;
            numbers[6] = Integer.parseInt("gfd");
        } catch (ArrayIndexOutOfBoundsException ex) {

            System.out.println("Выход за пределы массива");
        } catch (NumberFormatException ex) {

            System.out.println("Ошибка преобразования из строки в число");
        }
        //        Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку catch.
        //
        //        Оператор throw
        //            Чтобы сообщить о выполнении исключительных ситуаций в программе,
        //            можно использовать оператор throw. То есть с помощью этого оператора
        //            мы сами можем создать исключение и вызвать его в процессе выполнения.
        //            Например, в нашей программе происходит ввод числа, и мы хотим,
        //            чтобы, если число больше 30, то возникало исключение:
        //
        //          package firstapp;
        //          import java.util.Scanner;
        //          public class FirstApp {
        //            public static void main(String[] args) {
        //                try{
        //                    Scanner in = new Scanner(System.in);
        //                    int x = in.nextInt();
        //                    if(x>=30){
        //                        throw new Exception("Число х должно быть меньше 30");
        //                    }
        //                }
        //                catch(Exception ex){
        //                    System.out.println(ex.getMessage());
        //                }
        //                System.out.println("Программа завершена");
        //            }
        //          }
        //
        //        Здесь для создания объекта исключения используется конструктор
        //        класса Exception, в который передается сообщение об исключении.
        //        И если число х окажется больше 29, то будет выброшено исключение
        //        и управление перейдет к блоку catch.
        //
        //        В блоке catch мы можем получить сообщение об исключении
        //        с помощью метода getMessage().
        //
        //Комменты
        //        Это скорее похоже на вызов функции, чем на if или switch.
        //        Внутри try происходит вызов исключения с помощью throw (возможно,
        //        в вызываемых методах), в нем и создается объект исключения.
        //        Далее просматриваются ветки catch, выбирается первый подходящий класс,
        //        и вызывается соответствующая ветка с созданным объектом.
        //        Вызов throw null аналогичен throw new NullPointerException(),
        //        т.е. объект исключения создается всегда.
        //--------------------------------------------------------------------------------------

//"класс" и "объект"
        //            Java является объектно-ориентированным языком,
        //            поэтому такие понятия как "класс" и "объект"
        //            играют в нем ключевую роль. Любую программу на Java можно
        //            представить как набор взаимодействующих между собой объектов.
        //
        //            Шаблоном или описанием объекта является класс, а объект представляет
        //            экземпляр этого класса. Можно еще провести следующую аналогию.
        //            У нас у всех есть некоторое представление о человеке - наличие
        //            двух рук, двух ног, головы, туловища и т.д. Есть некоторый
        //            шаблон - этот шаблон можно назвать классом. Реально же
        //            существующий человек (фактически экземпляр данного класса)
        //            является объектом этого класса.
        //
        //            Класс определяется с помощью ключевого слова сlass:
        //
        //              class Person{
        //               }
        //
        //      В данном случае класс называется Person. После названия класса идут фигурные скобки,
        //      между которыми помещается тело класса - то есть его поля и методы.
        //
        //      Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные,
        //      которые хранит объект, и поведение - действия, которые может совершать объект.
        //
        //      Для хранения состояния объекта в классе применяются поля или переменные класса.
        //      Для определения поведения объекта в классе применяются методы. Например, класс Person, который представляет человека, мог бы иметь следующее определение:
        //
        //      class Person{
        //    String name;        // имя
        //    int age;            // возраст
        //    void displayInfo(){
        //        System.out.printf("Name: %s \tAge: %d\n", name, age);
        //        }
        //      }
        //
        //      В классе Person определены два поля: name представляет имя человека,
        //      а age - его возраст. И также определен метод displayInfo, который
        //      ничего не возвращает и просто выводит эти данные на консоль.
        //
        //    Теперь используем данный класс. Для этого определим следующую программу:
        //
        //  public class Program{
        //    public static void main(String[] args) {
        //
        //        Person tom;
        //    }
        //  }
        //  class Person{
        //
        //    String name;    // имя
        //    int age;        // возраст
        //    void displayInfo(){
        //        System.out.printf("Name: %s \tAge: %d\n", name, age);
        //      }
        //      }
        //
        //      Как правило, классы определяются в разных файлах. В данном случае для
        //      простоты мы определяем два класса в одном файле. Стоит отметить, что в этом
        //      случае только один класс может иметь модификатор public (в данном случае
        //      это класс Program), а сам файл кода должен называться по имени этого класса,
        //      то есть в данном случае файл должен называться Program.java.
        //
        //      Класс представляет новый тип, поэтому мы можем определять переменные,
        //      которые представляют данный тип. Так, здесь в методе main определена
        //      переменная tom, которая представляет класс Person. Но пока эта переменная
        //      не указывает ни на какой объект и по умолчанию она имеет значение null.
        //      По большому счету мы ее пока не можем использовать, поэтому вначале
        //      необходимо создать объект класса Person.
        //
// Конструкторы
        //      Кроме обычных методов классы могут определять специальные методы,
        //      которые называются конструкторами. Конструкторы вызываются при создании нового
        //      объекта данного класса. Конструкторы выполняют инициализацию объекта.
        //
        //      Если в классе не определено ни одного конструктора, то для этого класса
        //      автоматически создается конструктор без параметров.
        //
        //      Выше определенный класс Person не имеет никаких конструкторов.
        //      Поэтому для него автоматически создается конструктор по умолчанию,
        //      который мы можем использовать для создания объекта Person.
        //      В частности, создадим один объект:
        //
        //  public class Program{
        //    public static void main(String[] args) {
        //
        //        Person tom = new Person(); // создание объекта
        //        tom.displayInfo();
        //
        //        // изменяем имя и возраст
        //        tom.name = "Tom";
        //        tom.age = 34;
        //        tom.displayInfo();
        //    }
        //      }
        //    class Person{
        //
        //    String name;    // имя
        //    int age;        // возраст
        //    void displayInfo(){
        //        System.out.printf("Name: %s \tAge: %d\n", name, age);
        //    }
        //  }
        //
        //      Для создания объекта Person используется выражение new Person().
        //      Оператор new выделяет память для объекта Person. И затем вызывается конструктор
        //      по умолчанию, который не принимает никаких параметров. В итоге после выполнения
        //      данного выражения в памяти будет выделен участок, где будут храниться все данные
        //      объекта Person. А переменная tom получит ссылку на созданный объект.
        //      Если конструктор не инициализирует значения переменных объекта, то они
        //      получают значения по умолчанию. Для переменных числовых типов это число 0,
        //      а для типа string и классов - это значение null (то есть фактически
        //      отсутствие значения).
        //      После создания объекта мы можем обратиться к переменным объекта Person
        //      через переменную tom и установить или получить их значения, например,
        //      tom.name = "Tom".
        //
        //      Если необходимо, что при создании объекта производилась какая-то логика,
        //      например, чтобы поля класса получали какие-то определенные значения, то можно
        //      определить в классе свои конструкторы. Например:
        //
        //      public class Program{
        //      public static void main(String[] args) {
        //
        //        Person bob = new Person();      // вызов первого конструктора без параметров
        //        bob.displayInfo();
        //
        //        Person tom = new Person("Tom"); // вызов второго конструктора с одним параметром
        //        tom.displayInfo();
        //
        //        Person sam = new Person("Sam", 25); // вызов третьего конструктора с двумя параметрами
        //        sam.displayInfo();
        //      }
        //      }
        //      class Person{
        //
        //    String name;    // имя
        //    int age;        // возраст
        //    Person()
        //    {
        //        name = "Undefined";
        //        age = 18;
        //    }
        //    Person(String n)
        //    {
        //        name = n;
        //        age = 18;
        //    }
        //    Person(String n, int a)
        //    {
        //        name = n;
        //        age = a;
        //    }
        //    void displayInfo(){
        //        System.out.printf("Name: %s \tAge: %d\n", name, age);
        //    }
        //  }
        //      Теперь в классе определено три коструктора,
        //      каждый из которых принимает различное количество
        //      параметров и устанавливает значения полей класса.
        //
//Ключевое слово this
        //
        //       Ключевое слово this представляет ссылку на текущий экземпляр(объект) класса.
        //     Через это ключевое слово мы можем обращаться к переменным, методам объекта,
        //     а также вызывать его конструкторы. Например:
        //
        //     public class Program{
        //      public static void main(String[] args) {
        //        Person undef = new Person();
        //        undef.displayInfo();
        //
        //        Person tom = new Person("Tom");
        //        tom.displayInfo();
        //
        //        Person sam = new Person("Sam", 25);
        //        sam.displayInfo();
        //    }
        //  }
        //  class Person{
        //    String name;    // имя
        //    int age;        // возраст
        //    Person(){
        //        this("Undefined", 18);
        //    }
        //    Person(String name){
        //        this(name, 18);
        //    }
        //    Person(String name, int age)
        //    {
        //        this.name = name;
        //        this.age = age;
        //    }
        //    void displayInfo(){
        //        System.out.printf("Name: %s \tAge: %d\n", name, age);
        //    }
        //  }
        //  В третьем конструкторе параметры называются так же, как и поля класса. И чтобы разграничить
        //  поля и параметры, применяется ключевое слово this:
        //
        //  this.name = name;
        //
        //  Так, в данном случае указываем, что значение параметра name присваивается полю name.
        //
        //  Кроме того, у нас три конструктора, которые выполняют идентичные действия:
        //  устанавливают поля name и age. Чтобы избежать повторов, с помощью this можно вызвать
        //  один из конструкторов класса и передать для его параметров необходимые значения:
        //
        //  Person(String name)
        //  {
        //    this(name, 18);
        //  }
        //      В итоге результат программы будет тот же,
        //      что и в предыдущем примере.
        //
//Инициализаторы
        //      Кроме конструктора начальную инициализацию объекта вполне можно было проводить
        //      с помощью инициализатора объекта. Инициализатор выполняется до любого конструктора.
        //      То есть в инициализатор мы можем поместить код, общий для всех конструкторов:
        //
        //public class Program{
        //
        //    public static void main(String[] args) {
        //
        //        Person undef = new Person();
        //        undef.displayInfo();
        //
        //        Person tom = new Person("Tom");
        //        tom.displayInfo();
        //    }
        //}
        //
        //class Person{
        //
        //    String name;    // имя
        //    int age;        // возраст
        //
        //    /*начало блока инициализатора*/
        //        {
        //            name = "Undefined";
        //            age = 18;
        //        }
        //        /*конец блока инициализатора*/
        //        Person(){
        //    }
        //        Person(String name){
        //
        //        this.name = name;
        //    }
        //        Person(String name, int age){
        //
        //        this.name = name;
        //        this.age = age;
        //    }
        //        void displayInfo(){
        //        System.out.printf("Name: %s \tAge: %d\n", name, age);
        //    }
        //    }
        //
        //Коммент
        //        общее представление о человеке - это класс, а конкретный человек - это объект этого класса
        //
        //        Таким образом,
        //        класс - это шаблон для создания объекта,
        //        а объект - это экземпляр класса.
        //        А поскольку объект является экземпляром класса,
        //          то понятия объект и экземпляр употребляются как синонимы.
        //
        //        Обратите внимание на то, что в общей
        //        форме класса отсутствует определение метода main ().
        //        Классы jаvа могут и не содержать этот метод.
        //        Его обязательно указывать только в тех случаях, когда данный
        //        класс служит отправной точкой для выполнения программы.
        //
        //        Более того, в некоторые видах приложений jаvа вроде аплетов метод main()
        //        вообще не требуется.
        //
        //        Как пояснялось выше, класс определяет новый тип данных.
        //        В данном случае
        //        новый тип данных называется Person.
        //
        //        Это имя будет использоваться для объявления
        //        объектов "типа" Person.
        //
        //        Не следует забывать, что объявление с1аss создает только шаблон,
        //        но не конкретный объект.
        //
        //            Чтобы действительно создать объект класса Person,
        //            нужно воспользоваться оператором наподобие следующего:
        //
        //        Person myPerson = new Person() ; // создать объект myPerson класса Person
        //
        //        После выполнения этого оператора объект myPerson станет экземпляром т.е. оьъектом
        //        класса
        //        Person. Таким образом, он обретет "физическое" существование.
        //
        //        Напомним, что всякий раз, когда получается экземпляр класса,
        //        создается объект, который содержит собственную копию каждой переменной экземпляра,
        //        определенной в данном классе.
        //        Таким образом, каждый объект класса Person будет
        //        содержать собственные копии переменных экземпляра name и age.
        //
        //        Как пояснялось ранее, каждый объект содержит собственные копии переменных экземпляра(объекта).
        //        Это означает, что при наличии двух объектов класса Person каждый
        //        из них будет содержать собственные копии переменных name и age.
        //        Следует, однако, иметь в виду, что изменения в переменных экземпляра(объекта) одного
        //        объекта не влияют на переменные экземпляра(объекта) другого.
        //
        //        Еще раз рассмотрим отличие класса от объекта. Класс создает новый тип данных,
        //        который можно использовать для создания объектов. Это означает, что класс
        //        создает логический каркас, определяющий взаимосвязь между его членами. При
        //        объявлении объекта класса создается экземпляр этого класса. Таким образом,
        //        класс - это логическая конструкция, а объект имеет физическую сущность, т.е. он
        //
        //        занимает конкретную область оперативной памяти. Об этом отличии важно помнить
        //--------------------------------------------------------------------------------------

//    Пакеты
        //        Как правило, в Java классы объединяются в пакеты. Пакеты позволяют организовать классы
        //        логически в наборы. По умолчанию java уже имеет ряд встроенных пакетов, например, java.lang,
        //        java.util, java.io и т.д. Кроме того, пакеты могут иметь вложенные пакеты.
        //
        //        Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Ведь
        //        нередки ситуации, когда разработчики называют свои классы одинаковыми именами. Принадлежность
        //        к пакету позволяет гарантировать однозначность имен.
        //
        //            Чтобы указать, что класс принадлежит определенному пакету, надо использовать директиву
        //            package, после которой указывается имя пакета:
        //
        //  package название_пакета;
        //
        //        Как правило, названия пакетов соответствуют физической структуре проекта, то есть организации
        //        каталогов, в которых находятся файлы с исходным кодом. А путь к файлам внутри проекта соответствует
        //        названию пакета этих файлов. Например, если классы принадлежат пакету mypack, то эти классы
        //        помещаются в проекте в папку mypack.
        //
        //        Классы необязательно определять в пакеты. Если для класса пакет не определен, то считается,
        //        что данный класс находится в пакете по умолчанию, который не имеет имени.
        //
        //            Например, создадим в папке для исходных файлов каталог study. В нем создадим файл
        //            Program.java со следующим кодом:
        //
        //  package study;
        //        public class Program{
        //            public static void main(String[] args) {
        //                Person kate = new Person("Kate", 32);
        //                kate.displayInfo();
        //            }
        //        }
        //        class Person{
        //
        //            String name;
        //            int age;
        //
        //            Person(String name, int age){
        //                this.name = name;
        //                this.age = age;
        //            }
        //            void displayInfo(){
        //                System.out.printf("Name: %s \t Age: %d \n", name, age);
        //            }
        //        }
        //
        //        Директива package study в начале файла указывает, что классы Program и Person,
        //        которые здесь определены, принадлежат пакету study.
        //
        //        Когда мы работаем в среде разработке, например, в Netbeans, то IDE берет на себя все вопросы
        //        компиляции пакетов и входящих в них файлов. Соответственно нам достаточно нажать на кнопку,
        //        и все будет готово. Однако если мы компилируем программу в командной строке, то мы можем
        //        столкнуться с некоторыми трудностями. Поэтому рассмотрим этот аспект.
        //
        //        Для компиляции программы вначале в командной строке/терминале с помощью команды cd
        //        перейдем к папке, где находится каталог study.
        //
        //            cd C:\java
        //        Например, в моем случае это каталог C:\java (то есть файл с исходным кодом расположен
        //        по пути C:\java\study\Program.java).
        //
        //        Для компиляции выполним команду
        //
        //        javac study\Program.java
        //
        //        После этого в папке study появятся скомпилированные файлы Program.class и Person.class.
        //        Для запуска программы выполним команду:
        //
        //    java study.Program
        //
        //        Компиляция пакетов в Java
        //        Импорт пакетов и классов
        //        Если нам надо использовать классы из других пакетов, то нам надо подключить эти пакеты
        //        и классы. Исключение составляют классы из пакета java.lang (например, String), которые подключаются
        //        в программу автоматически.
        //
        //        Например, знакомый по прошлым темам класс Scanner находится в пакете java.util, поэтому
        //        мы можем получить к нему доступ следующим способом:
        //
        //        java.util.Scanner in = new java.util.Scanner(System.in);
        //
        //        То есть мы указываем полный путь к файлу в пакете при создании его объекта. Однако
        //        такое нагромождение имен пакетов не всегда удобно, и в качестве альтернативы мы можем импортировать
        //        пакеты и классы в проект с помощью директивы import, которая указывается после директивы package:
        //
        //  package study;
        //  import java.util.Scanner; // импорт класса Scanner
        //        public class Program {
        //            public static void main(String[] args) {
        //                Scanner in = new Scanner(System.in);
        //            }
        //        }
        //
        //        Директива import указывается в самом начале кода, после чего идет имя подключаемого
        //        класса (в данном случае класса Scanner).
        //
        //            В примере выше мы подключили только один класс, однако пакет java.util содержит
        //            еще множество классов. И чтобы не подключать по отдельности каждый класс, мы можем
        //            сразу подключить весь пакет:
        //
        //  import java.util.*; // импорт всех классов из пакета java.util
        //
        //        Теперь мы можем использовать любой класс из пакета java.util.
        //
        //            Возможна ситуация, когда мы используем два класса с одним и тем же названием из
        //            двух разных пакетов, например, класс Date имеется и в пакете java.util, и в пакете
        //            java.sql. И если нам надо одновременно использовать два этих класса, то необходимо
        //            указывать полный путь к этим классам в пакете:
        //
        //        java.util.Date utilDate = new java.util.Date();
        //        java.sql.Date sqlDate = new java.sql.Date();
        //        Статический импорт
        //        В java есть также особая форма импорта - статический импорт. Для этого вместе с
        //        директивой import используется модификатор static:
        //
        //  package study;
        //  import static java.lang.System.*;
        //  import static java.lang.Math.*;
        //
        //        public class Program {
        //
        //            public static void main(String[] args) {
        //
        //                double result = sqrt(20);
        //                out.println(result);
        //            }
        //        }
        //        Здесь происходит статический импорт классов System и Math. Эти классы имеют статические методы.
        //        Благодаря операции статического импорта мы можем использовать эти методы без названия класса.
        //        Например, писать не Math.sqrt(20), а sqrt(20), так как функция sqrt(), которая возвращает
        //        квадратный корень числа, является статической. (Позже мы рассмотрим статические члены класса).
        //
        //        То же самое в отношении класса System: в нем определен статический объект out, поэтому
        //        мы можем его использовать без указания класса.
        //--------------------------------------------------------------------------------------

//Модификаторы доступа

        //      Все члены класса в языке Java "поля", "методы" и "свойства" имеют модификаторы доступа.
        //      Модификаторы доступа позволяют задать допустимую область видимости для членов класса
        //
        //    public:публичный, общедоступный класс или член класса.Поля и методы,
        //    объявленные с модификатором public, видны другим классам из текущего пакета
        //    или из внешних пакетов.
        //
        //    private:закрытый класс или член класса, противоположность модификатору public.
        //    Закрытый класс или член класса доступен только из кода в том же классе.
        //
        //    protected:такой класс или член класса доступен из любого места
        //    в текущем классе или пакете или в производных классах,
        //    даже если они находятся в других пакетах
        //
        //    Отсутствие модификатора у поля или метода класса предполагает применение к
        //    нему модификатора по умолчанию.
        //    Такие поля или методы видны всем классам в текущем пакете.

        //                public class Program{
        //                    public static void main(String[] args) {

        //                        Person kate = new Person("Kate", 32, "Baker Street", "+12334567");
        //                        kate.displayName();     // норм, метод public
        //                        kate.displayAge();      // норм, метод имеет модификатор по умолчанию
        //                        kate.displayPhone();    // норм, метод protected
        //                        //kate.displayAddress();  // ! Ошибка, метод private

        //                        System.out.println(kate.name);      // норм, модификатор по умолчанию
        //                        System.out.println(kate.address);   // норм, модификатор public
        //                        System.out.println(kate.age);       // норм, модификатор protected
        //                        //System.out.println(kate.phone);   // ! Ошибка, модификатор private
        //                                    }
        //                                }
        //                                class Person{
        //
        //                                    String name;
        //                                    protected int age;
        //                                    public String address;
        //                                    private String phone;
        //
        //                                    public Person(String name, int age, String address, String phone){
        //                                        this.name = name;
        //                                        this.age = age;
        //                                        this.address = address;
        //                                        this.phone = phone;
        //                                    }
        //                                    public void displayName(){
        //                                        System.out.printf("Name: %s \n", name);
        //                                    }
        //                                    void displayAge(){ // не указан модификатор доступа значит public
        //                                        System.out.printf("Age: %d \n", age);
        //                                    }
        //                                    private void displayAddress(){ //доступен только этому классу
        // если вызов был из этого же класса
        //                                          Пример
        //                                           protected void displayPhone(){
        //                                           displayAddress("")

        //                                        System.out.printf("Address: %s \n", address);
        //                                    }
        //                                    protected void displayPhone(){ //Доступен только в этом классе
        //                                        System.out.printf("Phone: %s \n", phone);
        //                                    }}

        //        Поля и методы с модификатором private в классе Program не доступны.
        //
        //        Если бы класс Program располагался бы в другом пакете, то ему были бы доступны
        //        только поля и методы с модификатором public.
        //
        //        Модификатор доступа должен предшествовать определения переменной или метода.

//Инкапсуляция
        //        Использование различных модификаторов гарантирует,
        //        что данные не будут искажены или изменены не надлежащим
        //        образом. Подобное сокрытие данных внутри некоторой области видимости
        //        называется инкапсуляцией.
        //
        //                    public class Program{
        //                        public static void main(String[] args) {
        //
        //                            Person kate = new Person("Kate", 30);
        //                            System.out.println(kate.getAge());      // 30
        //                            kate.setAge(33);
        //                            System.out.println(kate.getAge());      // 33
        //                            kate.setAge(123450);
        //                            System.out.println(kate.getAge());      // 33
        //                                }
        //                            }
        //                                    class Person{
        //
        //                                        private String name;
        //                                        private int age;
        //
        //                                        public Person(String name, int age){
        //                                            this.name = name;
        //                                            this.age = age;
        //                                        }
        //                                        public String getName(){
        //                                            return this.name;
        //                                        }
        //                                        public void setName(String name){
        //                                            this.name = name;
        //                                        }
        //                                        public int getAge(){
        //                                            return this.age;
        //                                        }
        //                                        public void setAge(int age){
        //                                            if(age > 0 && age < 110)
        //                                                this.age = age;
        //                                }
        //                            }
        //        Методы setName,setAge и наподобие еще называют мьютейтерами (mutator) или "сеттер",
        //        так как они изменяют значения поля. А методы getName,
        //        getAge и наподобие называют аксессерами (accessor) т.е. "геттер",
        //        так как с их помощью мы получаем значение поля.
        //        Причем в данном случае при изменении возраста производится
        //        проверка, насколько соответствует новое значение допустимому диапазону.
        //--------------------------------------------------------------------------------------

    }

}




